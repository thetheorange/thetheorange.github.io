[{"title":"git commit message 标准","url":"/2024/09/10/git%20commit%E7%9A%84%E6%A0%87%E5%87%86/","content":"<h2 id=\"基本格式\"><a href=\"#基本格式\" class=\"headerlink\" title=\"基本格式\"></a>基本格式</h2><p><strong>type</strong> + 描述</p>\n<h2 id=\"type类型\"><a href=\"#type类型\" class=\"headerlink\" title=\"type类型\"></a>type类型</h2><ul>\n<li><strong>feat</strong> 新功能</li>\n<li>fix&#x2F;to <ul>\n<li>fix <strong>产生diff</strong>并自动修复问题。适合一次提交直接修复格式</li>\n<li>to <strong>只产生diff</strong>不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</li>\n</ul>\n</li>\n<li>docs 提交文档</li>\n<li>style 格式 不影响代码运行的变动 </li>\n<li>refactor 重构</li>\n<li>perf 优化</li>\n<li>test 测试 单元测试</li>\n<li>chore 构建过程或辅助工具的变动</li>\n<li>revert 回滚到上一个版本</li>\n<li>merge 代码合并</li>\n<li>sync 同步主线或分支的bug</li>\n</ul>\n","tags":["git"]},{"title":"位运算基础知识","url":"/2024/10/08/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"<h2 id=\"正数和负数在二进制中的表达\"><a href=\"#正数和负数在二进制中的表达\" class=\"headerlink\" title=\"正数和负数在二进制中的表达\"></a>正数和负数在二进制中的表达</h2><p>正数的二进制状态转负数的二进制：</p>\n<ol>\n<li>-1</li>\n<li>依次取反</li>\n</ol>\n<blockquote>\n<p>例：<br><code>7</code>的二进制为 <code>0111</code> 转为负数则为 <code>0110</code> -&gt; <code>1001</code></p>\n</blockquote>\n<p>负数的二进制状态转正数的二进制，为<strong>逆过程</strong>：</p>\n<ol>\n<li>依次取反</li>\n<li>+1</li>\n</ol>\n<blockquote>\n<p>例：<br><code>-7</code>的二进制为 <code>1001</code> 转为正数则为 <code>0110</code> -&gt; <code>0111</code></p>\n</blockquote>\n<h2 id=\"常见的位运算操作符\"><a href=\"#常见的位运算操作符\" class=\"headerlink\" title=\"常见的位运算操作符\"></a>常见的位运算操作符</h2><ul>\n<li><p><code>|</code> 或</p>\n<p>  相同位次中<strong>只要</strong>出现<code>1</code>则返回<code>1</code></p>\n<blockquote>\n<p>如 <code>0010 | 0111 = 0111</code></p>\n</blockquote>\n</li>\n<li><p><code>&amp;</code> 与</p>\n<p>  相同位次中<strong>都</strong>出现<code>1</code>则返回<code>1</code></p>\n<blockquote>\n<p>如 <code>0010 &amp; 0111 = 0010</code></p>\n</blockquote>\n</li>\n<li><p><code>~</code> 取反</p>\n<p>  <code>0</code>变成<code>1</code>，<code>1</code>变成<code>0</code></p>\n<blockquote>\n<p>如 <code>~0010 = 1101</code></p>\n</blockquote>\n</li>\n<li><p>^ 异或</p>\n<p>  相同位次中<strong>都</strong>不同才返回<code>1</code>，否则返回<code>0</code>。可以看成<em>无进位的相加</em></p>\n<blockquote>\n<p>如 <code>0010 ^ 0111 = 0101</code></p>\n</blockquote>\n</li>\n<li><p><code>&gt;&gt;</code> 右移 和 <code>&lt;&lt;</code> 左移</p>\n<p>  将二进制整体向左&#x2F;右移动<code>k</code>位，多出的位置用<code>0</code>补</p>\n<blockquote>\n<p>如 <code>0010 &gt;&gt; 1 = 0100</code> <code>0010 &gt;&gt; 1 = 0001</code></p>\n</blockquote>\n<p>  对于<strong>非负整数</strong>而言 左移相当于扩大<code>2</code>的<code>k</code>次方倍，左移相当于缩小<code>2</code>的<code>k</code>次方倍</p>\n</li>\n<li><p><code>&gt;&gt;&gt;</code> 右移</p>\n<p>  和<code>&gt;&gt;</code>功能相同，但是多出的位置用<em>符号位</em>补</p>\n<blockquote>\n<p>如 <code>1010 &gt;&gt;&gt; 1 = 1101</code></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"一些技巧\"><a href=\"#一些技巧\" class=\"headerlink\" title=\"一些技巧\"></a>一些技巧</h2><h3 id=\"取每个位次的数\"><a href=\"#取每个位次的数\" class=\"headerlink\" title=\"取每个位次的数\"></a>取每个位次的数</h3><p>对于32位的<code>int</code>类型数据，可以用如下方法依次取出每个位次的数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入num</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">31</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = (num &gt;&gt; i) &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">\tstd::cout &lt;&lt; tmp &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"向二进制状态填入1\"><a href=\"#向二进制状态填入1\" class=\"headerlink\" title=\"向二进制状态填入1\"></a>向二进制状态填入1</h3><p>对于<code>0</code>而言，可以用如下方法向指定位置填入<code>1</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans |= <span class=\"number\">1</span> &lt;&lt; i; <span class=\"comment\">// i为指定位置</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异或运算的性质和Brain-Kernighan算法\"><a href=\"#异或运算的性质和Brain-Kernighan算法\" class=\"headerlink\" title=\"异或运算的性质和Brain Kernighan算法\"></a>异或运算的性质和Brain Kernighan算法</h3><p>异或运算的性质：</p>\n<ol>\n<li><code>a ^ 0  = 0</code>、<code>a ^ a = 0</code> </li>\n<li>异或运算可以看成是无进位的相加</li>\n<li>异或运算满足交换律 即<code>a ^ b = c</code> -&gt; <code>c ^ b = a</code></li>\n<li>负数和正数的相互转化可以用<code>a = ~a + 1</code>，相当于<code>a = -a</code></li>\n</ol>\n<p>Brain Kernighan算法</p>\n<p>目的：提取出二进制状态<strong>最右边</strong>的<code>1</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> pos = a ^ (-a);</span><br></pre></td></tr></table></figure>\n","categories":["位运算"],"tags":["算法"]},{"title":"图的最短路径—Floyd算法和Bellman-Ford算法","url":"/2024/09/26/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94Floyd%E7%AE%97%E6%B3%95%E5%92%8CBellman-Ford%E7%AE%97%E6%B3%95/","content":"<h2 id=\"Floyd算法\"><a href=\"#Floyd算法\" class=\"headerlink\" title=\"Floyd算法\"></a>Floyd算法</h2><p>借助邻接矩阵辅助，Floyd算法可以解决数据量不大，且权值中有负数的图，但不能是存在负环的图的最短路径问题。该算法步骤如下：</p>\n<ol>\n<li>在<code>n</code>个节点中寻找”跳点”<code>bridge</code></li>\n<li>如果<code>graph[from][bridge] != INT_MAX &amp;&amp; graph[bridge][to] != INT_MAX &amp;&amp; graph[from][bridge] + graph[bridge][to] &lt; graph[from][to]</code> 则更新邻接矩阵</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> bridge = <span class=\"number\">0</span>; bridge &lt; n; ++bridge) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> from = <span class=\"number\">0</span>; from &lt; n; ++from)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> to = <span class=\"number\">0</span>; to &lt; n; ++to) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (graph[from][bridge] != INT_MAX &amp;&amp;</span><br><span class=\"line\">                graph[bridge][to] != INT_MAX &amp;&amp;</span><br><span class=\"line\">                graph[from][bridge] + graph[bridge][to] &lt; graph[from][to]) &#123;</span><br><span class=\"line\">                    graph[from][to] = graph[from][bridge] + graph[bridge][to];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显而易见，floyd算法的时间复杂度是<code>O(n^3)</code> 空间复杂度是<code>O(n^2)</code></p>\n<h2 id=\"Bellman-Ford算法\"><a href=\"#Bellman-Ford算法\" class=\"headerlink\" title=\"Bellman-Ford算法\"></a>Bellman-Ford算法</h2><p>Bellman-Ford 可以解决权值中存在负数，但不能存在负环的图，找出任意两点的最短路径问题。该算法步骤如下：</p>\n<ol>\n<li>初始化<code>distance</code>数组 即<code>vector&lt;int&gt;distance(n, INT_MAX);</code></li>\n<li>对所有边进行<code>n-1</code>的“松弛”（取最小值）操作</li>\n</ol>\n<p>算法模版如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">distance</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">distance[<span class=\"number\">0</span>] = <span class=\"number\">0</span>; <span class=\"comment\">// 源点设为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> edge : edges) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> from = edge[<span class=\"number\">0</span>], to = edge[<span class=\"number\">1</span>], weight = edge[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (distance[from] != INT_MAX) &#123;</span><br><span class=\"line\">            distance[to] = <span class=\"built_in\">min</span>(distance[to], distance[from] + weight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Bellman-Ford算法的时间复杂度为 <code>O(n^2)</code> 空间复杂度为<code>O(n)</code></p>\n","categories":["图论"],"tags":["算法"]},{"title":"平衡二叉树(AVL树)与二叉搜索树","url":"/2024/09/27/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"<h2 id=\"二叉搜索树-二叉排序树定义\"><a href=\"#二叉搜索树-二叉排序树定义\" class=\"headerlink\" title=\"二叉搜索树&#x2F;二叉排序树定义\"></a>二叉搜索树&#x2F;二叉排序树定义</h2><p>满足以下特征的二叉树，即为二叉搜索树：</p>\n<ol>\n<li>若左子树非空，则左子树上的所有节点要小于根节点</li>\n<li>若右子树非空，则右子树上的所有节点要大于根节点</li>\n<li>所有子结构满足上面两个条件</li>\n</ol>\n<h2 id=\"平衡二叉树的定义\"><a href=\"#平衡二叉树的定义\" class=\"headerlink\" title=\"平衡二叉树的定义\"></a>平衡二叉树的定义</h2><p>平衡二叉树，满足以下特征：</p>\n<ol>\n<li>左右子树的高度差不超过1</li>\n<li>所有子结构满足条件1</li>\n</ol>\n<h2 id=\"使用平衡二叉树优化二叉搜索树\"><a href=\"#使用平衡二叉树优化二叉搜索树\" class=\"headerlink\" title=\"使用平衡二叉树优化二叉搜索树\"></a>使用平衡二叉树优化二叉搜索树</h2><p>二叉搜索树在理想情况下查找效率是<code>O(logn)</code>的，但是在最坏情况下是<code>O(n)</code>的，比如下面这种情况:</p>\n<p><img src=\"/../images/bst.png\" alt=\"二叉搜索树\"></p>\n<p>但如果将这个二叉搜索树变为平衡二叉树，效率会得到大大提高，如下图：</p>\n<p><img src=\"/../images/per_bst.png\" alt=\"优化后的二叉搜索树\"></p>\n<h2 id=\"左旋和右旋\"><a href=\"#左旋和右旋\" class=\"headerlink\" title=\"左旋和右旋\"></a>左旋和右旋</h2><p>左旋和右旋是调整二叉树为平衡二叉树的两大“武器”</p>\n<h3 id=\"左旋\"><a href=\"#左旋\" class=\"headerlink\" title=\"左旋\"></a>左旋</h3><ul>\n<li>适用范围</li>\n</ul>\n<p>当最小失衡二叉树出现以下情况时，可以使用<strong>左旋</strong>进行调整</p>\n<p><img src=\"/../images/left_rotate.png\" alt=\"可以左旋的情况\"></p>\n<p>基本的步骤是：</p>\n<ol>\n<li>将<code>old_root</code>的右孩子<code>new_root</code>作为新的根节点</li>\n<li>如果<code>new_root</code>有左孩子，则将这个左孩子当做<code>old_root</code>的右孩子</li>\n<li>将<code>new_root</code>的做左孩子设为<code>old_root</code></li>\n</ol>\n<ul>\n<li>模版代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 左旋</span></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">leftRotate</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">\tNode* newRoot = root-&gt;right;</span><br><span class=\"line\">\tNode* tmp = newRoot-&gt;left;</span><br><span class=\"line\"></span><br><span class=\"line\">\troot-&gt;right = tmp;</span><br><span class=\"line\">\tnewRoot-&gt;left = root;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新高度</span></span><br><span class=\"line\">\troot-&gt;height = <span class=\"number\">1</span> + <span class=\"built_in\">max</span>(<span class=\"built_in\">getHeight</span>(root-&gt;left), <span class=\"built_in\">getHeight</span>(root-&gt;right));</span><br><span class=\"line\">\tnewRoot-&gt;height = <span class=\"number\">1</span> + <span class=\"built_in\">max</span>(<span class=\"built_in\">getHeight</span>(root), <span class=\"built_in\">getHeight</span>(newRoot-&gt;right));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newRoot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"右旋\"><a href=\"#右旋\" class=\"headerlink\" title=\"右旋\"></a>右旋</h3><ul>\n<li>适用范围</li>\n</ul>\n<p>当最小失衡二叉树出现以下情况时，可以使用<strong>右旋</strong>进行调整</p>\n<p><img src=\"/../images/right_rotate.png\" alt=\"可以右旋的情况\"></p>\n<p>基本的步骤是：</p>\n<ol>\n<li>将<code>old_root</code>的左孩子<code>new_root</code>作为新的根节点</li>\n<li>如果<code>new_root</code>有右孩子，则将这个右孩子当做<code>old_root</code>的左孩子</li>\n<li>将<code>new_root</code>的右孩子设为<code>old_root</code></li>\n</ol>\n<ul>\n<li>模版代码</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 右旋</span></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">rightRotate</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">\tNode* newRoot = root-&gt;left;</span><br><span class=\"line\">\tNode* tmp = newRoot-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">\troot-&gt;left = tmp;</span><br><span class=\"line\">\tnewRoot-&gt;right = root;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新高度</span></span><br><span class=\"line\">\troot-&gt;height = <span class=\"number\">1</span> + <span class=\"built_in\">max</span>(<span class=\"built_in\">getHeight</span>(root-&gt;left), <span class=\"built_in\">getHeight</span>(root-&gt;right));</span><br><span class=\"line\">\tnewRoot-&gt;height = <span class=\"number\">1</span> + <span class=\"built_in\">max</span>(<span class=\"built_in\">getHeight</span>(newRoot-&gt;left), <span class=\"built_in\">getHeight</span>(root));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newRoot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四种类型\"><a href=\"#四种类型\" class=\"headerlink\" title=\"四种类型\"></a>四种类型</h2><h3 id=\"LL\"><a href=\"#LL\" class=\"headerlink\" title=\"LL\"></a>LL</h3><p>LL类型情况如下：</p>\n<p><img src=\"/../images/LL.png\" alt=\"LL类型\"></p>\n<p>判断条件：</p>\n<ol>\n<li><code>old_root</code>的平衡因子<strong>大于</strong>1</li>\n<li><code>new_root</code>的平衡因子<strong>大于</strong>0</li>\n</ol>\n<p>只需对<code>old_root</code>进行右旋即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &gt; <span class=\"number\">1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;left) &gt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">leftRotate</span>(root);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"LR\"><a href=\"#LR\" class=\"headerlink\" title=\"LR\"></a>LR</h3><p>LR类型情况如下:</p>\n<p><img src=\"/../images/LR.png\" alt=\"LR类型\"></p>\n<p>判断条件：</p>\n<ol>\n<li><code>old_root</code>的平衡因子<strong>大于</strong>1</li>\n<li><code>new_root</code>的平衡因子<strong>小于</strong>0</li>\n</ol>\n<p>操作步骤：</p>\n<ol>\n<li>先对<code>new_root</code>进行<em>左旋</em></li>\n<li>再对<code>old_root</code>进行<em>右旋</em></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &gt; <span class=\"number\">1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;left) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\troot-&gt;left = <span class=\"built_in\">leftRotate</span>(root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">rightRotate</span>(root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RR\"><a href=\"#RR\" class=\"headerlink\" title=\"RR\"></a>RR</h3><p>RR类型情况如下：</p>\n<p><img src=\"/../images/RR.png\" alt=\"RR类型\"></p>\n<p>判断条件：</p>\n<ol>\n<li><code>old_root</code>的平衡因子<strong>小于</strong>-1</li>\n<li><code>new_root</code>的平衡因子<strong>小于</strong>0</li>\n</ol>\n<p>只需对<code>old_root</code>进行左旋即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &lt; <span class=\"number\">-1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;right) &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">rightRotate</span>(root);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"RL\"><a href=\"#RL\" class=\"headerlink\" title=\"RL\"></a>RL</h3><p>RL类型情况如下：</p>\n<p><img src=\"/../images/RL.png\" alt=\"RL类型\"></p>\n<p>判断条件：</p>\n<ol>\n<li><code>old_root</code>的平衡因子<strong>小于</strong>-1</li>\n<li><code>new_root</code>的平衡因子<strong>大于</strong>0</li>\n</ol>\n<p>操作步骤：</p>\n<ol>\n<li>先对<code>new_root</code>进行<em>右旋</em></li>\n<li>再对<code>old_root</code>进行<em>左旋</em></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &lt; <span class=\"number\">-1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;left) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\troot-&gt;right = <span class=\"built_in\">rightRotate</span>(root-&gt;right);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">leftRotate</span>(root);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入节点</span></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">insert</span><span class=\"params\">(Node* root, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(val);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class=\"line\">\t\troot-&gt;right = <span class=\"built_in\">insert</span>(root-&gt;right, val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class=\"line\">\t\troot-&gt;left = <span class=\"built_in\">insert</span>(root-&gt;left, val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新高度</span></span><br><span class=\"line\">\troot-&gt;height = <span class=\"number\">1</span> + <span class=\"built_in\">max</span>(<span class=\"built_in\">getHeight</span>(root-&gt;left), <span class=\"built_in\">getHeight</span>(root-&gt;right));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 平衡性调整</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &lt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// RL</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root-&gt;right) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\troot-&gt;right = <span class=\"built_in\">rightRotate</span>(root-&gt;right);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">leftRotate</span>(root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// RR</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">leftRotate</span>(root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// LR</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root-&gt;left) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\troot-&gt;left = <span class=\"built_in\">leftRotate</span>(root-&gt;left);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">rightRotate</span>(root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// LL</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">rightRotate</span>(root);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除节点</span></span><br><span class=\"line\"><span class=\"function\">Node* <span class=\"title\">delete_node</span><span class=\"params\">(Node* root, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (root-&gt;val == val) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tNode* tmp = root-&gt;right;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (tmp-&gt;left) tmp = tmp-&gt;left;</span><br><span class=\"line\">\t\t\ttmp-&gt;left = root-&gt;left;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class=\"built_in\">delete_node</span>(root-&gt;right, val);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class=\"built_in\">delete_node</span>(root-&gt;left, val);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!root) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 更新树高</span></span><br><span class=\"line\">\troot-&gt;height = <span class=\"number\">1</span> + <span class=\"built_in\">max</span>(<span class=\"built_in\">getHeight</span>(root-&gt;left), <span class=\"built_in\">getHeight</span>(root-&gt;right));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 调整二叉树</span></span><br><span class=\"line\">\t<span class=\"comment\">// LL</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &gt; <span class=\"number\">1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;left) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">rightRotate</span>(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// LR</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &gt; <span class=\"number\">1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;left) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\troot-&gt;left = <span class=\"built_in\">leftRotate</span>(root-&gt;left);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">rightRotate</span>(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// RR</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &lt; <span class=\"number\">-1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;right) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">leftRotate</span>(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// RL</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">getBalance</span>(root) &lt; <span class=\"number\">-1</span> &amp;&amp; <span class=\"built_in\">getBalance</span>(root-&gt;right) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\troot-&gt;right = <span class=\"built_in\">rightRotate</span>(root-&gt;right);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">leftRotate</span>(root);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":["二叉树"],"tags":["算法"]},{"title":"二分查找的一些思考","url":"/2024/09/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83-md/","content":"<h2 id=\"二分查找的流程\"><a href=\"#二分查找的流程\" class=\"headerlink\" title=\"二分查找的流程\"></a>二分查找的流程</h2><p>先来看一个问题：</p>\n<p><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">力扣704 二分查找</a></p>\n<blockquote>\n<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>\n</blockquote>\n<p>这题的暴力解很容易想到，就是依次遍历，直到找到target，否则则返回-1。这样做的时间复杂度为O(n)</p>\n<p>暴力解忽略了题目中<strong>有序数组</strong>的条件。在这种条件下，使用二分查找能节省大量的时间。</p>\n<p><code>输入 nums = [5,7,7,8,8,10], target = 8</code></p>\n<p>我们使用两个指针：左指针和右指针分别指向数组的0下标和len(nums)-1 (这里采用的是闭区间写法)</p>\n<p>每次的循环中，我们取left和right区间中间的数(这里记为nums[mid])，将nums[mid]同target进行比较。</p>\n<p>这时候有三种情况：</p>\n<ol>\n<li>nums[mid] &gt; target 此时right应该缩小 即right &#x3D; mid - 1</li>\n<li>nums[mid] &lt; target 此时left应该前进 即left &#x3D; mid + 1</li>\n<li>nums[mid] &#x3D; target 此时返回mid即可</li>\n</ol>\n<p>由此，我们就可以得到下面这段代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = l + (r - l) / <span class=\"number\">2</span>; <span class=\"comment\">// 这里为了防止溢出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &gt; nums[mid]) l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[mid]) r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// 没有找到结果直接返回-1就好</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二分查找时间复杂度和空间复杂度\"><a href=\"#二分查找时间复杂度和空间复杂度\" class=\"headerlink\" title=\"二分查找时间复杂度和空间复杂度\"></a>二分查找时间复杂度和空间复杂度</h2><p>由于我们每次都是在中间选取，所以二分查找的时间复杂度应该为O(log 2)</p>\n<p>二分查找算法中，因为只用了几个变量作为参数，所以空间复杂度为O(1)</p>\n<h2 id=\"二分查找的要求\"><a href=\"#二分查找的要求\" class=\"headerlink\" title=\"二分查找的要求\"></a>二分查找的要求</h2><p>是否能进行二分查找，要满足两个条件：</p>\n<ol>\n<li>数组为顺序存储 (链表不适用)</li>\n<li>数组中元素有序</li>\n</ol>\n<p>数组为顺序存储这个条件比较好理解。如果题目给定的是一个链表的话，因为链表不能够直接从下标获取到元素，而是要通过遍历得到，所以对链表使用二分查找显然不是十分有效率。</p>\n<p>数组中元素有序，这个条件的重点在<strong>有序</strong>。这里的有序当然不仅仅包含，单调递增或是单调递减，这里的有序可以理解为广义上的<strong>有序</strong>。例如<a href=\"https://leetcode.cn/problems/peak-index-in-a-mountain-array\">力扣852. 山脉数组的峰顶索引</a>，就不是按照所有元素单调性的有序进行存储，但是只要我们可以根据nums[mid]来确定数组元素的大小，就可以认定为有序。</p>\n<h2 id=\"四种情况的讨论\"><a href=\"#四种情况的讨论\" class=\"headerlink\" title=\"四种情况的讨论\"></a>四种情况的讨论</h2><p>在二分查找中，抓住<strong>循环不变量</strong>很关键：</p>\n<p>以704为例</p>\n<p>[0, l-1] x &lt; target<br>[r+1, n-1] x &gt; target</p>\n<p>在二分查找中，其实有四种情况：</p>\n<ol>\n<li><code>&gt;=</code></li>\n<li><code>&gt;</code></li>\n<li><code>&lt;=</code></li>\n<li><code>&lt;</code></li>\n</ol>\n<p>我们来看这道题目 <a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">力扣34. 在排序数组中查找元素的第一个和最后一个位置\n</a></p>\n<blockquote>\n<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>\n</blockquote>\n<p>这道题目其实相当于让我们求第1和3种情况</p>\n<p>我们先来求第三种情况 &lt;&#x3D;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = l + (r - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; nums[mid]) l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事实上，&lt;&#x3D; 是能和其他三种情况相互转换的。</p>\n<p><code>&lt; target 可转化为 &lt;= (target) - 1</code><br><code>&gt; target 可转化为 &gt;= (target + 1)</code><br><code>&gt;= target 可转化为 (&lt;= target + 1) - 1</code></p>\n<p>那么，本题就可以先计算出<code>&lt;=</code>的情况 再由此推出<code>&gt;=</code>的情况</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">lower_bound</span>(nums, target);</span><br><span class=\"line\">        <span class=\"comment\">// 如果没找到target</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == nums.<span class=\"built_in\">size</span>() || nums[start] != target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// &gt;= target 可转化为 (&lt;= target + 1) - 1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> end = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">lower_bound</span>(nums, target<span class=\"number\">+1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = start; res[<span class=\"number\">1</span>] = end;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"特别感谢\"><a href=\"#特别感谢\" class=\"headerlink\" title=\"特别感谢\"></a>特别感谢</h1><p>感谢灵神，给我带来的启发qwq</p>\n","categories":["数组"],"tags":["算法"]},{"title":"图的最短路径—BFS和Dijkstra算法","url":"/2024/09/23/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E2%80%94BFS%E5%92%8CDijkstra%E7%AE%97%E6%B3%95/","content":"<h2 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h2><h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>针对无权图，给定一个起始点，要求其他点到起始点的最短路径，可以使用BFS（广度优先搜索）算法得出结果。</p>\n<h3 id=\"代码实现和原理分析\"><a href=\"#代码实现和原理分析\" class=\"headerlink\" title=\"代码实现和原理分析\"></a>代码实现和原理分析</h3><p>给出下面一个图，假设起始点为3</p>\n<p><img src=\"/../images/graph.png\" alt=\"有向无权图\"></p>\n<p>使用<code>distance数组</code>和<code>visited数组</code>分别记录每个点的最短路径和该点是否被访问过。</p>\n<p>如需记录最短路径，则需要<code>path数组</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">distance</span><span class=\"params\">(n<span class=\"number\">+1</span>, <span class=\"number\">-1</span>)</span></span>; <span class=\"comment\">// -1表示距离无穷大 如果遍历结束后distance[i]为-1 则表示与这个节点不相通</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n<span class=\"number\">+1</span>, <span class=\"literal\">false</span>)</span></span>; <span class=\"comment\">// 初始化为false 表示默认都没访问到</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">path</span><span class=\"params\">(n<span class=\"number\">+1</span>, <span class=\"number\">-1</span>)</span></span>; <span class=\"comment\">// 记录前驱节点</span></span><br></pre></td></tr></table></figure>\n\n<p>对于起始点，其<code>distance[start]</code>应该初始化为<code>0</code>， <code>visited[start]</code>初始化为<code>true</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">distance[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\">visited[start] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>开始广度优先搜索，<strong>依次标记每个未访问的节点为访问状态</strong>，这样做可以保证最短路径的节点，<strong>最先被标记</strong>， 同时也可以避免成环问题 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> size = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (size--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 遍历邻居</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> neighbor : graph[cur]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">                distance[neighbor] = distance[cur] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                path[neighbor] = cur;</span><br><span class=\"line\">                visited[neighbor] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>完整代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 构造图</span></span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; graph&#123; &#123;&#125;, &#123;<span class=\"number\">4</span>&#125;, &#123;<span class=\"number\">5</span>&#125;, &#123;<span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">2</span>&#125;, &#123;<span class=\"number\">3</span>&#125; &#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">distance</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">path</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">\tdistance[<span class=\"number\">3</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tvisited[<span class=\"number\">3</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 开始广度优先搜索</span></span><br><span class=\"line\">\tqueue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> size = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (size--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> neighbor : graph[cur]) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!visited[neighbor]) &#123;</span><br><span class=\"line\">\t\t\t\t\tdistance[neighbor] = distance[cur] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t\tpath[neighbor] = cur;</span><br><span class=\"line\">\t\t\t\t\tvisited[neighbor] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印distance数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : distance) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 打印path数组</span></span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : path) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"时空复杂度分析\"><a href=\"#时空复杂度分析\" class=\"headerlink\" title=\"时空复杂度分析\"></a>时空复杂度分析</h3><p>因为需要访问所有节点（最坏情况下）所以时间复杂度应该为 <code>O(V+E)</code> n为节点数量</p>\n<p>空间复杂度 考虑到<code>distance</code>、<code>visited</code>和<code>path</code>数组的开销 应为<code>O(V)</code></p>\n<h2 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h2><h3 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>针对<strong>有权图</strong>，求最短路径问题，这里介绍的是使用<strong>堆</strong>进行优化的Dijkstra算法，而非暴力的Dijkstra算法</p>\n<h3 id=\"代码实现和原理分析-1\"><a href=\"#代码实现和原理分析-1\" class=\"headerlink\" title=\"代码实现和原理分析\"></a>代码实现和原理分析</h3><p>给出一个有权图，起点为1</p>\n<p><img src=\"/../images/weight_graph.png\" alt=\"有向有权图\"></p>\n<p>Dijkstra算法的具体步骤，可以分为以下几点：</p>\n<ol>\n<li>创建<code>distance</code>数组和<code>visited</code>数组，分别用于记录<em>最短路径</em>和<em>该节点是否已被访问</em>，这里的visited，还有另一层含义，即表示该节点的最短路径是否已经确定。</li>\n<li>初始化<code>distance</code>和<code>visited</code>数组，设置<code>distance[start] = 0;</code>，同时需注意<code>distance</code>数组中的<strong>初始值要尽可能大</strong></li>\n<li>建立小根堆，将初始节点压入堆中</li>\n<li>从小根堆中弹出元素<ol>\n<li>如果该节点未访问过 则<code>visited[cur] = true;</code></li>\n<li>如果该节点已访问过 则<code>continue</code></li>\n<li>处理各边<ol>\n<li>如果<code>!visited[neighbor] &amp;&amp; distance[cur] + weight &lt; distance[neighbor]</code>，则进行更新，即<code>distance[neighbor] = distance[cur] + weight; q.push(neighbor);</code></li>\n<li>其他情况不处理</li>\n</ol>\n</li>\n<li>重复第4步骤，直到小根堆为空</li>\n</ol>\n</li>\n</ol>\n<p>具体的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dijkstra</span></span><br><span class=\"line\"><span class=\"comment\">// 创建图</span></span><br><span class=\"line\">vector&lt;vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&gt; graph&#123; &#123;&#123;&#125;&#125;, &#123;&#123;<span class=\"number\">2</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">100</span>&#125;, &#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;&#125;, &#123;&#123;<span class=\"number\">3</span>, <span class=\"number\">3</span>&#125;&#125;, &#123;&#123;<span class=\"number\">5</span>, <span class=\"number\">2</span>&#125;&#125;, &#123;&#123;&#125;&#125;, &#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">5</span>&#125;, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>&#125;&#125; &#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> start = <span class=\"number\">1</span>, n = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">distance</span><span class=\"params\">(n + <span class=\"number\">1</span>, INT_MAX)</span></span>;</span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">distance[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> cmp = [](vector&lt;<span class=\"type\">int</span>&gt;&amp; a, vector&lt;<span class=\"type\">int</span>&gt;&amp; b) -&gt; <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &gt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 使用优先队列创建小根堆</span></span><br><span class=\"line\">priority_queue&lt;vector&lt;<span class=\"type\">int</span>&gt;, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;, <span class=\"keyword\">decltype</span>(cmp)&gt;<span class=\"built_in\">q</span>(cmp);</span><br><span class=\"line\">q.<span class=\"built_in\">push</span>(&#123; start, <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; cur = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (visited[cur[<span class=\"number\">0</span>]]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\tvisited[cur[<span class=\"number\">0</span>]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理各边</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> neighbor : graph[cur[<span class=\"number\">0</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// neighbor.size() &gt; 0判空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (neighbor.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span> &amp;&amp; !visited[neighbor[<span class=\"number\">0</span>]] &amp;&amp; cur[<span class=\"number\">1</span>] + neighbor[<span class=\"number\">1</span>] &lt; distance[neighbor[<span class=\"number\">0</span>]]) &#123;</span><br><span class=\"line\">\t\t\tdistance[neighbor[<span class=\"number\">0</span>]] = cur[<span class=\"number\">1</span>] + neighbor[<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(&#123;neighbor[<span class=\"number\">0</span>], distance[neighbor[<span class=\"number\">0</span>]]&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打印distance数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : distance) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"时空复杂度分析-1\"><a href=\"#时空复杂度分析-1\" class=\"headerlink\" title=\"时空复杂度分析\"></a>时空复杂度分析</h3><p>因为要遍历每一条边和每一个节点且要经过堆的调整 所以时间复杂度为 <code>O((V + E) log V)</code><br>空间复杂度显然为 <code>O(V)</code></p>\n","categories":["图论"],"tags":["算法"]},{"title":"并查集的原理和应用","url":"/2024/09/23/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/","content":"<h2 id=\"1-结构实现\"><a href=\"#1-结构实现\" class=\"headerlink\" title=\"1. 结构实现\"></a>1. 结构实现</h2><p>并查集要实现三个方法：</p>\n<ol>\n<li><code>int find(int x);</code> 查找代表元素</li>\n<li><code>bool isSameSet(int x, int y);</code> 查看是否为同一集合</li>\n<li><code>void _union(int x, int y);</code> 合并集合</li>\n</ol>\n<p>而并查集的结构，我们可以使用数组（顺序表）进行存储。数组下标<code>i</code>表示每个节点，数组的值<code>father[i]</code>对应着这个节点的代表节点。</p>\n<p>对于<code>father</code>数组的初始化，我们有如下代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的n是节点总数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) father[i] = i;</span><br></pre></td></tr></table></figure>\n\n<p>这样初始化，表示着每个节点一开始代表着自己。后期我们查找某个节点的代表节点的时候，只需依次跳转，直到<code>father[i] == i</code>就表示找到代表节点了</p>\n<p>接下来，我们依次来看前面三种方法的实现</p>\n<h3 id=\"1-1-find\"><a href=\"#1-1-find\" class=\"headerlink\" title=\"1.1 find\"></a>1.1 find</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x != father[x]) father[x] = <span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> father[x];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，这里在每次的递归中<code>father[x] = find(x);</code>保证最后的<em>扁平化</em>，保证时间复杂度保持在常数级别。</p>\n<h3 id=\"1-2-isSameSet\"><a href=\"#1-2-isSameSet\" class=\"headerlink\" title=\"1.2 isSameSet\"></a>1.2 isSameSet</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSameSet</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(x) == <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查看代表元素是否相同，如果相同则表示在同一个集合中</p>\n<h3 id=\"1-3-union\"><a href=\"#1-3-union\" class=\"headerlink\" title=\"1.3 _union\"></a>1.3 _union</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _union(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fx = <span class=\"built_in\">find</span>(x), fy = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    <span class=\"comment\">// 如果不是同一个集合 则进行合并</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fx != fy) &#123;</span><br><span class=\"line\">        father[fx] = fy; <span class=\"comment\">// 只需修改代表节点即可合并</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-具体案例\"><a href=\"#2-具体案例\" class=\"headerlink\" title=\"2. 具体案例\"></a>2. 具体案例</h2><p><a href=\"https://leetcode.cn/problems/satisfiability-of-equality-equations/description/\">990. 等式方程的可满足性</a></p>\n<blockquote>\n<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a&#x3D;&#x3D;b” 或 “a!&#x3D;b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>\n<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 </p>\n</blockquote>\n<p>这题我们可以将相等看作两个节点<strong>联通</strong>，或者说，这两个节点属于同一个集合。而不等式可以看作这两个节点不属于同一个节点。</p>\n<p>也就是说，我们使用并查集，先将等式的组合进行合并，再根据不等式中的字母元素，判断该元素是否同属一个节点。一旦出现矛盾，则返回<code>false</code></p>\n<p>解题代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        1. 对于所有的等式 可以看成合并操作</span></span><br><span class=\"line\"><span class=\"comment\">        2. 对应所有的不等式 看成这两个元素不在同一个集合中</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; father;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEqual</span><span class=\"params\">(string <span class=\"type\">const</span>&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s[<span class=\"number\">1</span>] == <span class=\"string\">&#x27;=&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x != father[x]) father[x] = <span class=\"built_in\">find</span>(father[x]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> father[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Union</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fx = <span class=\"built_in\">find</span>(x), fy = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fx != fy) &#123;</span><br><span class=\"line\">            father[fx] = fy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSameSet</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(x) == <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">equationsPossible</span><span class=\"params\">(vector&lt;string&gt;&amp; equations)</span> </span>&#123;</span><br><span class=\"line\">        father.<span class=\"built_in\">assign</span>(<span class=\"number\">26</span>, <span class=\"number\">0</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> i = <span class=\"string\">&#x27;a&#x27;</span>; i &lt;= <span class=\"string\">&#x27;z&#x27;</span>; ++i) father[i-<span class=\"string\">&#x27;a&#x27;</span>] = i-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> s : equations) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isEqual</span>(s)) <span class=\"built_in\">Union</span>(s[<span class=\"number\">0</span>]-<span class=\"string\">&#x27;a&#x27;</span>, s.<span class=\"built_in\">back</span>()-<span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> s : equations) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">isEqual</span>(s)) <span class=\"keyword\">if</span> (<span class=\"built_in\">isSameSet</span>(s[<span class=\"number\">0</span>]-<span class=\"string\">&#x27;a&#x27;</span>, s.<span class=\"built_in\">back</span>()-<span class=\"string\">&#x27;a&#x27;</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>","categories":["数组"],"tags":["算法"]},{"title":"预算内的最多机器人数目——二分答案和单调队列","url":"/2024/09/14/%E9%A2%84%E7%AE%97%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%95%B0%E7%9B%AE%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p><a href=\"https://leetcode.cn/problems/maximum-number-of-robots-within-budget/description/\">2398. 预算内的最多机器人数目</a></p>\n<blockquote>\n<p>你有 n 个机器人，给你两个下标从 0 开始的整数数组 <code>chargeTimes</code> 和 <code>runningCosts</code> ，两者长度都为 n 。第 i 个机器人充电时间为 <code>chargeTimes[i]</code> 单位时间，花费 <code>runningCosts[i]</code> 单位时间运行。再给你一个整数 budget 。</p>\n<p>运行 k 个机器人 总开销 是 <code>max(chargeTimes) + k * sum(runningCosts)</code> ，其中 <code>max(chargeTimes)</code> 是这 k 个机器人中最大充电时间，<code>sum(runningCosts)</code> 是这 k 个机器人的运行时间之和。</p>\n<p>请你返回在 不超过 <code>budget</code> 的前提下，你 最多 可以 <strong>连续</strong> 运行的机器人数目为多少。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25</span><br><span class=\"line\"></span><br><span class=\"line\">输出：3</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。</span><br><span class=\"line\">选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。</span><br><span class=\"line\">可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>这题的关键是<strong>连续</strong>。</p>\n<p>因为<strong>连续</strong>，我们可以得出这样一个结论：</p>\n<p>假设说有k为最多的可以连续运行机器人数目，那么必定有 <code>k-1，k-2，k-3 ...</code> 的机器人满足条件。</p>\n<p>反过来，那就必定有 <code>k+1，k+2，k+3 ...</code> 的机器人不满足条件。</p>\n<p>而且k的范围必定在 <code>[0, chargeTimes.size()]</code> 里</p>\n<p>这样想，其实我们可以使用二分查找，来查找我们的答案。因为对于<code>k</code>的范围而言，<code>k</code>的范围可以视为一个单调递增的数组。而<code>k</code>相当于二分查找中的<code>mid</code>，<code>mid</code>左边的数满足条件，<code>mid</code>右边的数不满足条件。</p>\n<p>为了方便，我们使用开区间写法（不用考虑<code>mid+1</code>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = chargeTimes.<span class=\"built_in\">size</span>()<span class=\"number\">+1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (left + <span class=\"number\">1</span> &lt; right) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid)) left = mid; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> right = mid;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">return</span> left;</span><br></pre></td></tr></table></figure>\n\n<p>这个时候 <code>left</code> 就是答案。</p>\n<p>这里的check函数的作用是，检测k个连续的机器人是否合法，合法的标准是 <code>max(chargeTimes) + k * sum(runningCosts)</code>。转换一下，其实可以翻译成，在一个数组中，取<code>n</code>个长度为<code>k</code>的滑动窗口，判断这<code>n</code>个窗口中，是否存在一个窗口满足条件。</p>\n<p>这样看，是不是和<a href=\"https://leetcode.cn/problems/sliding-window-maximum/description/\">239. 滑动窗口最大值\n</a>的思路十分相似。</p>\n<p>接下来，我们先来解决这个题目。</p>\n<h3 id=\"前置题目和单调队列\"><a href=\"#前置题目和单调队列\" class=\"headerlink\" title=\"前置题目和单调队列\"></a>前置题目和单调队列</h3><blockquote>\n<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回 滑动窗口中的最大值 。</p>\n</blockquote>\n<p>对于这道题而言，暴力解法就是取长度为k的滑动窗口，遍历整个数组，依次取窗口的最大值，最后返回结果即可。假设每个窗口大小为1的情况下，暴力解法的时间复杂度为<code>O(n^2)</code>，会明显地超时。</p>\n<p>另一种想法是，每次的滑动窗口的最大值，并不需要我们每次重新求值，而是可能和上次的<strong>值</strong>有关。</p>\n<p>例如，<code>[1,3,-1,-3,5,3,6,7]</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">滑动窗口的位置                最大值</span><br><span class=\"line\">---------------               -----</span><br><span class=\"line\">[1  3  -1] -3  5  3  6  7       3</span><br><span class=\"line\"> 1 [3  -1  -3] 5  3  6  7       3</span><br></pre></td></tr></table></figure>\n\n<p>第一个窗口和第二个窗口的最大值其实是重复的，因为第二个滑动窗口向右滑动的时候，新加入的-3并没有大过3，而且，左边的边界收缩的时候，3也并没有移除，所以取3。</p>\n<p>既然如此，我们只要维护每个窗口的最大值就行了？</p>\n<p>最直白的想法，可能是使用优先队列<code>priority_queue</code>， 但是对于优先队列，找到最大值很容易，移除元素很困难，因为我们要维护最大值。</p>\n<p><em>如果有一种队列能够保持最大值且删除元素很容易，那就好了</em></p>\n<p>抱着这样的想法，我们可以引入<strong>单调队列</strong>。</p>\n<p><code>push</code>时，每次都保证队头元素为最大的元素。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>() &amp;&amp; q.<span class=\"built_in\">back</span>() &lt; val) q.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><code>pop</code>时，当队头元素为目标元素时，应该将其移除。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">empty</span>() &amp;&amp; q.<span class=\"built_in\">front</span>() == val) q.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样，我们再使用<strong>滑动窗口</strong>的思想，当窗口长度为k时，取队头元素，使用<code>pop(val)</code>移除元素，不为k时，则维护最大值，使用<code>push(val)</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; que;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">empty</span>() &amp;&amp; <span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">front</span>() == val) <span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!<span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">empty</span>() &amp;&amp; <span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">back</span>() &lt; val) <span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">pop_back</span>(); <span class=\"comment\">// 比最大值小的数且在最大值前面的数无意义 可以直接去掉</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; ret;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> right = <span class=\"number\">0</span>; right &lt; nums.<span class=\"built_in\">size</span>(); ++right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> len = right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">push</span>(nums[right]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &lt;= nums.<span class=\"built_in\">size</span>() - k &amp;&amp; len == k) &#123;</span><br><span class=\"line\">                ret.<span class=\"built_in\">push_back</span>(<span class=\"keyword\">this</span>-&gt;que.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">pop</span>(nums[left++]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解决本题\"><a href=\"#解决本题\" class=\"headerlink\" title=\"解决本题\"></a>解决本题</h3><p>对于本题的<code>max(chargeTimes) + k * sum(runningCosts)</code>合法条件，<code>max(chargeTimes)</code>其实就是维护每个长度为<code>k</code>的滑动窗口的最大值，对于<code>sum(runningCosts)</code>，维护的是每一个窗口的总和。</p>\n<p>这样一来，思路就很明显了。代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>() &amp;&amp; q.<span class=\"built_in\">back</span>() &lt; val) q.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">empty</span>() &amp;&amp; q.<span class=\"built_in\">front</span>() == val) q.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximumRobots</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; chargeTimes, vector&lt;<span class=\"type\">int</span>&gt;&amp; runningCosts, <span class=\"type\">long</span> <span class=\"type\">long</span> budget)</span> </span>&#123;</span><br><span class=\"line\">        function&lt;<span class=\"type\">bool</span>(<span class=\"type\">int</span>)&gt;check = [&amp;](<span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">clear</span>(); <span class=\"comment\">// 每次判断前 一定要进行初始化 否则会导致上一次的最大值残留</span></span><br><span class=\"line\">            <span class=\"comment\">// 求取每个窗口的最大值</span></span><br><span class=\"line\">            <span class=\"type\">int</span> l = <span class=\"number\">0</span>, n = chargeTimes.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> r = <span class=\"number\">0</span>; r &lt; n; ++r) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> len = r - l + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">push</span>(chargeTimes[r]);</span><br><span class=\"line\">                sum += runningCosts[r];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (l &lt;= n - k &amp;&amp; len == k) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((q.<span class=\"built_in\">front</span>()+k*sum)&lt;= budget) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">pop</span>(chargeTimes[l]);</span><br><span class=\"line\">                    sum -= runningCosts[l++];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = chargeTimes.<span class=\"built_in\">size</span>()<span class=\"number\">+1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left + <span class=\"number\">1</span> &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid)) left = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> right = mid;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间、空间复杂度分析\"><a href=\"#时间、空间复杂度分析\" class=\"headerlink\" title=\"时间、空间复杂度分析\"></a>时间、空间复杂度分析</h2><p>以下<code>n</code>为<code>chargeTimes</code>数组的长度</p>\n<p>时间：<code>O((log 2)*n)</code> 二分答案加滑动窗口<br>空间复杂度： <code>O(n)</code> 假如<code>k</code>为n时，需要申请大小为<code>n</code>的双端队列。 </p>\n","categories":["数组"],"tags":["算法"]},{"title":"排序算法总结","url":"/2024/09/30/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","content":"<h2 id=\"辅助函数\"><a href=\"#辅助函数\" class=\"headerlink\" title=\"辅助函数\"></a>辅助函数</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交换函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = nums[x];</span><br><span class=\"line\">\tnums[x] = nums[y];</span><br><span class=\"line\">\tnums[y] = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">test</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : nums) cout &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">选择排序</span></span><br><span class=\"line\"><span class=\"comment\">在每一轮找到最小的值插入到数组前面</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 无</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selectionSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> min_el = INT_MAX, min_index = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nums[j] &lt; min_el) &#123;</span><br><span class=\"line\">\t\t\t\tmin_el = nums[j];</span><br><span class=\"line\">\t\t\t\tmin_index = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(nums, i, min_index);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">两两比较大小 大的数字往后移</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - i; ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n &amp;&amp; nums[j] &gt; nums[j + <span class=\"number\">1</span>]) <span class=\"built_in\">swap</span>(nums, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">直接插入排序</span></span><br><span class=\"line\"><span class=\"comment\">依次选择最小的值插入到数组前面</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 有</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j + <span class=\"number\">1</span>] &lt; nums[j]; --j)</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(nums, j + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二分插入排序\"><a href=\"#二分插入排序\" class=\"headerlink\" title=\"二分插入排序\"></a>二分插入排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">二分插入排序</span></span><br><span class=\"line\"><span class=\"comment\">根据前面数组的有序性 二分查找最小的值插入到数组前面</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 有</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = start, r = end;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x &gt; nums[mid]) l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertSort_2</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 前2个元素按从小到大排序</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nums[<span class=\"number\">1</span>] &lt; nums[<span class=\"number\">0</span>]) <span class=\"built_in\">swap</span>(nums, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = <span class=\"built_in\">lower_bound</span>(nums, <span class=\"number\">0</span>, i - <span class=\"number\">1</span>, nums[i] + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tpos = pos == n ? n - <span class=\"number\">1</span> : pos;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = nums[i];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 插入元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i - <span class=\"number\">1</span>; j &gt;= pos; --j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(nums, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">希尔排序</span></span><br><span class=\"line\"><span class=\"comment\">对子表进行插入排序</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度O(1)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 无</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (d &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 以下为插入排序的流程 不过步长改为了d</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = d; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i - d; j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[j + d] &lt; nums[j]; j -= d) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">swap</span>(nums, j + d, j);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\td /= <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">快速排序</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n logn)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(logn)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 无</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 快速排序 第一种写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (start &gt;= end) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> left = start, right = end, pivot = nums[start];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 移动右指针 直到遇到小于pivot的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; left &lt; right &amp;&amp; nums[right] &gt;= pivot; )  --right;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理比pivot小的元素</span></span><br><span class=\"line\">\t\tnums[left] = nums[right];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 移动左指针 直到遇到大于pivot的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; left &lt; right &amp;&amp; nums[left] &lt;= pivot; ) ++left;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 处理比pivot大的元素</span></span><br><span class=\"line\">\t\tnums[right] = nums[left];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 归位pivot</span></span><br><span class=\"line\">\tnums[left] = pivot;</span><br><span class=\"line\">\t<span class=\"built_in\">quickSort</span>(nums, start, left - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">quickSort</span>(nums, left + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 快速排序 第二种写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort2</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pivot = nums[l], slow = l;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nums[i] &lt;= pivot) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(nums, i, slow);</span><br><span class=\"line\">\t\t\t++slow;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(nums, slow - <span class=\"number\">1</span>, l);</span><br><span class=\"line\">\t<span class=\"built_in\">quickSort2</span>(nums, l, slow - <span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">quickSort2</span>(nums, slow, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">堆排序</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n logn)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(1)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 无</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 向上调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapInsert</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; heap, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">1</span> &amp;&amp; heap[i] &gt; heap[(i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>]) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(heap, i, (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>);</span><br><span class=\"line\">\t\ti = (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向下调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapify</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; heap, <span class=\"type\">int</span> i, <span class=\"type\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt; size) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 从左右孩子中选出最大的孩子</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mx = l + <span class=\"number\">1</span> &lt; size &amp;&amp; heap[l] &lt; heap[l + <span class=\"number\">1</span>] ? l + <span class=\"number\">1</span> : l;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 比较最大的孩子与当前元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (heap[i] &gt;= heap[mx]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果当前元素比最大的孩子小 则向最大的孩子移动</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(heap, i, mx);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新 i, l</span></span><br><span class=\"line\">\t\ti = mx;</span><br><span class=\"line\">\t\tl = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建堆 自下而上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build_bottom</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; ns)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = ns.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">heapify</span>(ns, i, n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建堆 自上而下</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build_top</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; ns)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = ns.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">heapInsert</span>(ns, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">void</span>(*build)(vector&lt;<span class=\"type\">int</span>&gt;&amp; ns))</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), last = n;</span><br><span class=\"line\">\t<span class=\"comment\">// 建堆 </span></span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(nums);</span><br><span class=\"line\">\t<span class=\"comment\">// 大数归位</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (last &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(nums, <span class=\"number\">0</span>, last - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t--last;</span><br><span class=\"line\">\t\t<span class=\"built_in\">heapify</span>(nums, <span class=\"number\">0</span>, last);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">归并排序</span></span><br><span class=\"line\"><span class=\"comment\">递归将数组分成两部分 分别将这两部分排序好 再合并 最后将辅助数组里面的值刷回原数组</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 有</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> mid, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">help</span><span class=\"params\">((<span class=\"type\">int</span>)nums.size(), <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 辅助数组</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> i = l, a = l, b = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a &lt;= mid &amp;&amp; b &lt;= r) &#123;</span><br><span class=\"line\">\t\thelp[i++] = nums[a] &lt;= nums[b] ? nums[a++] : nums[b++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 必有一个指针越界 要么是a 要么是b</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a &lt;= mid) &#123;</span><br><span class=\"line\">\t\thelp[i++] = nums[a++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (b &lt;= r) &#123;</span><br><span class=\"line\">\t\thelp[i++] = nums[b++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 将辅助数组中的数据刷回原数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = l; j &lt;= r; ++j) &#123;</span><br><span class=\"line\">\t\tnums[j] = help[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(nums, l, mid);</span><br><span class=\"line\">\t<span class=\"built_in\">mergeSort</span>(nums, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\t<span class=\"built_in\">merge</span>(nums, l, mid, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"桶排序（基数排序）\"><a href=\"#桶排序（基数排序）\" class=\"headerlink\" title=\"桶排序（基数排序）\"></a>桶排序（基数排序）</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">桶排序 (基数排序)</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度 O(n)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度 O(n + k) k为桶的数量</span></span><br><span class=\"line\"><span class=\"comment\">稳定性 有</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// 十进制</span></span><br><span class=\"line\"><span class=\"type\">int</span> BASE = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"comment\">// 计数位数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">countDigit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tx /= BASE;</span><br><span class=\"line\">\t\t++cnt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> min_el = INT_MAX, max_el = INT_MIN, n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// 获取最小值和最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : nums) &#123;</span><br><span class=\"line\">\t\tmin_el = <span class=\"built_in\">min</span>(min_el, i);</span><br><span class=\"line\">\t\tmax_el = <span class=\"built_in\">max</span>(max_el, i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// bits：nums中最大值的位数</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> bits = <span class=\"built_in\">countDigit</span>(max_el);</span><br><span class=\"line\">\t<span class=\"comment\">// 将nums中的所有值减去最小值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) nums[i] -= min_el;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">help</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 桶排序</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> offset = <span class=\"number\">1</span>, i = <span class=\"number\">0</span>; i &lt; bits; ++i, offset *= BASE) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">cnts</span><span class=\"params\">(BASE, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 统计各个位数的次数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : nums) cnts[(num / offset) % BASE]++;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算前缀位数次序和</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; BASE; ++j) cnts[j] += cnts[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 倒序遍历nums 插入对应位置的元素到help中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; --j) &#123;</span><br><span class=\"line\">\t\t\thelp[--cnts[(nums[j] / offset) % BASE]] = nums[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将help数组中的值刷入nums中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) nums[j] = help[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 还原数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) nums[i] += min_el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":["数组"],"tags":["算法"]},{"title":"最小生成树—kruskal和prim算法","url":"/2024/09/26/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E2%80%94kruskal%E5%92%8Cprim%E7%AE%97%E6%B3%95/","content":"<h2 id=\"Kruskal算法模版\"><a href=\"#Kruskal算法模版\" class=\"headerlink\" title=\"Kruskal算法模版\"></a>Kruskal算法模版</h2><ol>\n<li>按各边权值进行从小到大排序</li>\n<li>检测是否有环（使用并查集）<ol>\n<li>如果两节点属于同一个集合 则说明有环</li>\n<li>如果两节点不属于同一个集合 不成环则进行合并</li>\n</ol>\n</li>\n</ol>\n<p>借助洛谷上的<a href=\"https://www.luogu.com.cn/problem/P3366\">最小生成树</a></p>\n<blockquote>\n<p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 orz。<br>输入格式</p>\n<p>第一行包含两个整数 N,MN,M，表示该图共有 NN 个结点和 MM 条无向边。</p>\n<p>接下来 MM 行每行包含三个整数 Xi,Yi,ZiXi​,Yi​,Zi​，表示有一条长度为 ZiZi​ 的无向边连接结点 Xi,YiXi​,Yi​。<br>输出格式</p>\n<p>如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 orz。</p>\n</blockquote>\n<p>模版代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; father;</span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构建并查集</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; ++i) father.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 查询并查集</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x != father[x]) father[x] = <span class=\"built_in\">find</span>(father[x]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> father[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 合并</span></span><br><span class=\"line\"><span class=\"type\">void</span> _union(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> w) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fx = <span class=\"built_in\">find</span>(x), fy = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (fx != fy) &#123;</span><br><span class=\"line\">\t\tfather[fy] = fx;</span><br><span class=\"line\">\t\tans += w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> N, M;</span><br><span class=\"line\">\tcin &gt;&gt; N &gt;&gt; M;</span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; edge;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; M; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> from, to, weight;</span><br><span class=\"line\">\t\tcin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class=\"line\">\t\tedge.<span class=\"built_in\">push_back</span>(&#123; from, to, weight &#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> cmp = [](vector&lt;<span class=\"type\">int</span>&gt;&amp; a, vector&lt;<span class=\"type\">int</span>&gt;&amp; b) -&gt; <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a[<span class=\"number\">2</span>] &lt; b[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\">\t<span class=\"comment\">// 根据权值排序</span></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(edge.<span class=\"built_in\">begin</span>(), edge.<span class=\"built_in\">end</span>(), cmp);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(N);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : edge) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> from = e[<span class=\"number\">0</span>], to = e[<span class=\"number\">1</span>], w = e[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果不成环 则合并</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find</span>(from) != <span class=\"built_in\">find</span>(to)) &#123;</span><br><span class=\"line\">\t\t\t_union(from, to, w);</span><br><span class=\"line\">\t\t\tcnt++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果成环 则跳过</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt == N<span class=\"number\">-1</span>) cout &lt;&lt; ans;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&quot;orz&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Prim算法模版\"><a href=\"#Prim算法模版\" class=\"headerlink\" title=\"Prim算法模版\"></a>Prim算法模版</h2><p>prim算法和Dijkstra算法十分类似</p>\n<p>过程如下：</p>\n<ol>\n<li>创建visited数组 初始设为false 即<code>vector&lt;bool&gt;visited(n, false);</code></li>\n<li>任取一个点 将这个点的所有边加入到小根堆中</li>\n<li>当小根堆不为空 则弹出元素<ol>\n<li>弹出元素若已访问过 则<code>continue</code></li>\n<li>弹出元素若未访问过 则<code>visited[cur] = true;</code> 这里可以计算最小生成树的权值 如<code>ans += weight</code></li>\n<li>处理各边 将各边加入到堆中</li>\n</ol>\n</li>\n<li>当小根堆为空 也就得到了最小生成树</li>\n</ol>\n<p>针对洛谷上的模版题（见前文）也可以使用prim算法进行计算</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建图</span></span><br><span class=\"line\">    <span class=\"type\">int</span> N, M;</span><br><span class=\"line\">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class=\"line\">    vector&lt;vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">graph</span>(N + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; M; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> from, to, weight;</span><br><span class=\"line\">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class=\"line\">        graph[from].<span class=\"built_in\">push_back</span>(&#123; to, weight &#125;);</span><br><span class=\"line\">        graph[to].<span class=\"built_in\">push_back</span>(&#123; from, weight &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 开始 Prim 算法</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">visited</span><span class=\"params\">(N + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>, cnt = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> cmp = [](vector&lt;<span class=\"type\">int</span>&gt;&amp; a, vector&lt;<span class=\"type\">int</span>&gt;&amp; b)-&gt; <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &gt; b[<span class=\"number\">1</span>]; <span class=\"comment\">// 使用小根堆</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    priority_queue&lt;vector&lt;<span class=\"type\">int</span>&gt;, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;, <span class=\"keyword\">decltype</span>(cmp)&gt; <span class=\"built_in\">q</span>(cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : graph[<span class=\"number\">1</span>]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">    visited[<span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; cur = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> from = cur[<span class=\"number\">0</span>], weight = cur[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[from]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        visited[from] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        ans += weight; <span class=\"comment\">// 累加当前边的权重</span></span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理各边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> neighbor : graph[from]) &#123;</span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>(neighbor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 检查是否所有节点都被访问</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cnt == N) &#123;</span><br><span class=\"line\">        cout &lt;&lt; ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;orz&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时空复杂度分析\"><a href=\"#时空复杂度分析\" class=\"headerlink\" title=\"时空复杂度分析\"></a>时空复杂度分析</h2><p>kruskal算法：</p>\n<ul>\n<li>时间复杂度 <code>O(E * log E)</code></li>\n<li>空间复杂度 <code>O(V)</code></li>\n</ul>\n<p>prim算法</p>\n<ul>\n<li>时间复杂度 <code>O(E * log V)</code></li>\n<li>空间复杂度 <code>O(V)</code></li>\n</ul>\n","categories":["图论"],"tags":["算法"]}]