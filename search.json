[{"title":"git commit message 标准","url":"/2024/09/10/standard/","content":"<h2 id=\"基本格式\"><a href=\"#基本格式\" class=\"headerlink\" title=\"基本格式\"></a>基本格式</h2><p><strong>type</strong> + 描述</p>\n<h2 id=\"type类型\"><a href=\"#type类型\" class=\"headerlink\" title=\"type类型\"></a>type类型</h2><ul>\n<li><strong>feat</strong> 新功能</li>\n<li>fix&#x2F;to <ul>\n<li>fix <strong>产生diff</strong>并自动修复问题。适合一次提交直接修复格式</li>\n<li>to <strong>只产生diff</strong>不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</li>\n</ul>\n</li>\n<li>docs 提交文档</li>\n<li>style 格式 不影响代码运行的变动 </li>\n<li>refactor 重构</li>\n<li>perf 优化</li>\n<li>test 测试 单元测试</li>\n<li>chore 构建过程或辅助工具的变动</li>\n<li>revert 回滚到上一个版本</li>\n<li>merge 代码合并</li>\n<li>sync 同步主线或分支的bug</li>\n</ul>\n","tags":["git"]},{"title":"二分查找的一些思考.md","url":"/2024/09/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83-md/","content":"<h2 id=\"二分查找的流程\"><a href=\"#二分查找的流程\" class=\"headerlink\" title=\"二分查找的流程\"></a>二分查找的流程</h2><p>先来看一个问题：</p>\n<p><a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">力扣704 二分查找</a></p>\n<blockquote>\n<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>\n</blockquote>\n<p>这题的暴力解很容易想到，就是依次遍历，直到找到target，否则则返回-1。这样做的时间复杂度为O(n)</p>\n<p>暴力解忽略了题目中<strong>有序数组</strong>的条件。在这种条件下，使用二分查找能节省大量的时间。</p>\n<p><code>输入 nums = [5,7,7,8,8,10], target = 8</code></p>\n<p>我们使用两个指针：左指针和右指针分别指向数组的0下标和len(nums)-1 (这里采用的是闭区间写法)</p>\n<p>每次的循环中，我们取left和right区间中间的数(这里记为nums[mid])，将nums[mid]同target进行比较。</p>\n<p>这时候有三种情况：</p>\n<ol>\n<li>nums[mid] &gt; target 此时right应该缩小 即right &#x3D; mid - 1</li>\n<li>nums[mid] &lt; target 此时left应该前进 即left &#x3D; mid + 1</li>\n<li>nums[mid] &#x3D; target 此时返回mid即可</li>\n</ol>\n<p>由此，我们就可以得到下面这段代码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = l + (r - l) / <span class=\"number\">2</span>; <span class=\"comment\">// 这里为了防止溢出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target &gt; nums[mid]) l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[mid]) r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; <span class=\"comment\">// 没有找到结果直接返回-1就好</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二分查找时间复杂度和空间复杂度\"><a href=\"#二分查找时间复杂度和空间复杂度\" class=\"headerlink\" title=\"二分查找时间复杂度和空间复杂度\"></a>二分查找时间复杂度和空间复杂度</h2><p>由于我们每次都是在中间选取，所以二分查找的时间复杂度应该为O(log 2)</p>\n<p>二分查找算法中，因为只用了几个变量作为参数，所以空间复杂度为O(1)</p>\n<h2 id=\"二分查找的要求\"><a href=\"#二分查找的要求\" class=\"headerlink\" title=\"二分查找的要求\"></a>二分查找的要求</h2><p>是否能进行二分查找，要满足两个条件：</p>\n<ol>\n<li>数组为顺序存储 (链表不适用)</li>\n<li>数组中元素有序</li>\n</ol>\n<p>数组为顺序存储这个条件比较好理解。如果题目给定的是一个链表的话，因为链表不能够直接从下标获取到元素，而是要通过遍历得到，所以对链表使用二分查找显然不是十分有效率。</p>\n<p>数组中元素有序，这个条件的重点在<strong>有序</strong>。这里的有序当然不仅仅包含，单调递增或是单调递减，这里的有序可以理解为广义上的<strong>有序</strong>。例如<a href=\"https://leetcode.cn/problems/peak-index-in-a-mountain-array\">力扣852. 山脉数组的峰顶索引</a>，就不是按照所有元素单调性的有序进行存储，但是只要我们可以根据nums[mid]来确定数组元素的大小，就可以认定为有序。</p>\n<h2 id=\"四种情况的讨论\"><a href=\"#四种情况的讨论\" class=\"headerlink\" title=\"四种情况的讨论\"></a>四种情况的讨论</h2><p>在二分查找中，抓住<strong>循环不变量</strong>很关键：</p>\n<p>以704为例</p>\n<p>[0, l-1] x &lt; target<br>[r+1, n-1] x &gt; target</p>\n<p>在二分查找中，其实有四种情况：</p>\n<ol>\n<li><code>&gt;=</code></li>\n<li><code>&gt;</code></li>\n<li><code>&lt;=</code></li>\n<li><code>&lt;</code></li>\n</ol>\n<p>我们来看这道题目 <a href=\"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/\">力扣34. 在排序数组中查找元素的第一个和最后一个位置\n</a></p>\n<blockquote>\n<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>\n</blockquote>\n<p>这道题目其实相当于让我们求第1和3种情况</p>\n<p>我们先来求第三种情况 &lt;&#x3D;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lower_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = l + (r - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; nums[mid]) l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事实上，&lt;&#x3D; 是能和其他三种情况相互转换的。</p>\n<p><code>&lt; target 可转化为 &lt;= (target) - 1</code><br><code>&gt; target 可转化为 &gt;= (target + 1)</code><br><code>&gt;= target 可转化为 (&lt;= target + 1) - 1</code></p>\n<p>那么，本题就可以先计算出<code>&lt;=</code>的情况 再由此推出<code>&gt;=</code>的情况</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">lower_bound</span>(nums, target);</span><br><span class=\"line\">        <span class=\"comment\">// 如果没找到target</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == nums.<span class=\"built_in\">size</span>() || nums[start] != target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// &gt;= target 可转化为 (&lt;= target + 1) - 1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> end = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">lower_bound</span>(nums, target<span class=\"number\">+1</span>) - <span class=\"number\">1</span>;</span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = start; res[<span class=\"number\">1</span>] = end;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"特别感谢\"><a href=\"#特别感谢\" class=\"headerlink\" title=\"特别感谢\"></a>特别感谢</h1><p>感谢灵神，给我带来的启发qwq</p>\n","tags":["算法"]}]